---
title: "Cluster Demografici"
output: html_notebook
---

# Analisi cluster demografici con algoritmo non supervisionato (k-mean)

**RQ:** *A partire dalla stratificazione del dataset per categorie demografiche, è possibile individuare cluster in relazione ai fenomeni osservati?*

# Filtro topic: Diabetes & Cardiovascular Disease

```{r}
library(dplyr)

dataset_path <- "u_s_chronic_disease_indicators_cdi.csv"

df <- read.csv(dataset_path, na.strings = c("", "NA", "NULL", "null"))

df_filtered <- df %>%
  filter(topic %in% c("Diabetes", "Cardiovascular Disease"))

```

### Conteggio categorie demografiche univoche

```{r}
df_filtered %>%
  filter(stratificationcategory1 == "Race/Ethnicity") %>%
  count(stratification1) %>%
  arrange(desc(n))

```

### Visualizzazione question univoche

```{r}
library(dplyr)

qid_map <- df_filtered %>%
  distinct(questionid, question) %>%
  arrange(questionid)

# Mostra la tabella
knitr::kable(qid_map, col.names = c("QuestionID", "Question"))

```

# Preparazione datavalue per K-Means

```{r}
library(dplyr)

# conversione in numerico di datavalue (da eventuale stringa) e gestione virgole (da , a .)
df_k <- df_filtered %>%
  mutate(
    datavalue_num = suppressWarnings(as.numeric(gsub(",", ".", datavalue, fixed = TRUE))),
    .row = dplyr::row_number()
  )

```

# K-Means (k = 7) per ciascuna combinazione (topic, questionid, datavaluetypeid)

```{r}
library(dplyr)    # gestione dati
library(purrr)    # funzioni di mappatura

set.seed(9)       # seme per riproducibilità

clustered <- df_k %>%
  group_by(topic, questionid, datavaluetypeid) %>%   # raggruppa per variabili chiave
  group_modify(~{                                   # lavora su ogni gruppo
    d <- .x                                         # sottoinsieme del gruppo
    d_non_na <- d %>% filter(!is.na(datavalue_num)) # tiene solo valori non NA

    if (nrow(d_non_na) < 7) {                       # se meno di 7 righe
      d$cluster <- NA_integer_                      # assegna NA al cluster
      d                                             # restituisce i dati così
    } else {
      km <- kmeans(d_non_na$datavalue_num,          # kmeans su 7 cluster
                   centers = 7, nstart = 25)       
      d_non_na$cluster <- km$cluster                # assegna etichette cluster

      d %>% left_join(d_non_na %>%                  # riunisce cluster con dati
                        select(.row, cluster), 
                      by = ".row")
    }
  }) %>%
  ungroup()                                         # toglie il raggruppamento

clustered %>%
  select(topic, questionid, datavaluetypeid,        # mostra colonne chiave
         datavalue_num, cluster) %>%
  head()                                            # prime righe


```

# Percentuali per stratification (solo Race/Ethnicity) dentro ciascun cluster

```{r}
library(dplyr)
library(tidyr)

# calcolo delle percentuali per ogni cluster e stratification
cluster_strat_pct <- clustered %>%
  # filtra solo i record con categoria race/ethnicity ed esclude cluster mancanti
  filter(stratificationcategory1 == "Race/Ethnicity", !is.na(cluster)) %>%
  # raggruppa per topic, questionid, datavaluetypeid e cluster
  group_by(topic, questionid, datavaluetypeid, cluster) %>%
  # calcola la dimensione totale del cluster
  mutate(cluster_total = n()) %>%
  # raggruppa ulteriormente per stratification1
  group_by(topic, questionid, datavaluetypeid, cluster, stratification1) %>%
  # calcola il numero di elementi per ogni combinazione
  summarise(
    n = n(),
    cluster_total = dplyr::first(cluster_total),
    .groups = "drop_last"
  ) %>%
  # calcola la percentuale di ciascuna categoria sul totale del cluster
  mutate(pct = 100 * n / cluster_total) %>%
  # rimuove i raggruppamenti
  ungroup() %>%
  # ordina i risultati
  arrange(topic, questionid, datavaluetypeid, cluster, desc(pct))

# anteprima delle prime 20 righe della tabella finale
cluster_strat_pct %>% head(20)

```

# Grafico d’esempio sulla combinazione più rappresentata

```{r}
library(dplyr)   # gestione dati
library(tidyr)   # funzioni di reshaping

cluster_strat_pct <- clustered %>%
  filter(stratificationcategory1 == "Race/Ethnicity", !is.na(cluster)) %>% # tiene solo race/ethnicity e cluster validi
  group_by(topic, questionid, datavaluetypeid, cluster) %>%                # raggruppa per cluster e variabili base
  mutate(cluster_total = n()) %>%                                          # totale righe per cluster
  group_by(topic, questionid, datavaluetypeid, cluster, stratification1) %>% # aggiunge stratificazione
  summarise(
    n = n(),                                                               # conta righe per gruppo
    cluster_total = dplyr::first(cluster_total),                           # riporta totale cluster
    .groups = "drop_last"
  ) %>%
  mutate(pct = 100 * n / cluster_total) %>%                                # percentuale sul cluster
  ungroup() %>%                                                            # toglie il raggruppamento
  arrange(topic, questionid, datavaluetypeid, cluster, desc(pct))          # ordina in modo leggibile

cluster_strat_pct %>% head(20)  # anteprima prime 20 righe

```

```{r}
combos <- cluster_strat_pct %>%
  dplyr::distinct(topic, questionid, datavaluetypeid) %>%   # combinazioni uniche
  dplyr::arrange(topic, questionid, datavaluetypeid)        # ordinate

for (i in seq_len(nrow(combos))) {                          # ciclo sulle combinazioni
  tp  <- combos$topic[i]                                    # topic corrente
  qid <- combos$questionid[i]                               # questionid corrente
  dvt <- combos$datavaluetypeid[i]                          # typeid corrente
  
  p <- plot_pies_for_combo(tp, qid, dvt)                    # genera il grafico
  print(p)                                                  # mostra il grafico
}

}
```
