# ordina gli anni in modo crescente (fattore ordinato per x)
yearstart = as.factor(as.integer(yearstart))
)
# Aggrega per topic, anno, status
agg <- df %>%
group_by(topic, yearstart, status) %>%
summarise(n = n(), .groups = "drop")
# Ordina i topic per numerosità totale (facilita la lettura)
topic_order <- agg %>%
group_by(topic) %>%
summarise(total = sum(n), .groups = "drop") %>%
arrange(desc(total)) %>%
pull(topic)
agg$topic <- factor(agg$topic, levels = topic_order)
# Plot: barre impilate Validi (blu) / Mancanti (rosso), facet per topic
p <- ggplot(agg, aes(x = yearstart, y = n, fill = status)) +
geom_col() +
facet_wrap(~ topic, scales = "free_y") +
labs(
title = "Distribuzione dei record per anno e topic",
subtitle = "",
x = "Anno (yearstart)",
y = "Numero di record",
fill = NULL
) +
scale_fill_manual(values = c("Validi" = "blue", "Mancanti" = "red")) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
strip.text = element_text(face = "bold"),
plot.title = element_text(face = "bold")
)
print(p)
library(grid)
library(gtable)
# --- Parametri ---
dataset_path <- "u_s_chronic_disease_indicators_cdi.csv"
MAX_ROWS_PER_BLOCK <- 40   # righe per tabella prima di spezzare
SHOW_TOPICS <- NULL        # es. c("Alcohol","Cancer") per limitarli; NULL = tutti
# --- Caricamento e preparazione ---
df <- read.csv(dataset_path, stringsAsFactors = FALSE)
names(df) <- tolower(names(df))
req_cols <- c("topic", "questionid", "datavaluetype", "datavalueunit")
miss <- setdiff(req_cols, names(df))
if (length(miss) > 0) stop("Mancano queste colonne nel CSV: ", paste(miss, collapse = ", "))
df_clean <- df %>%
mutate(datavalueunit = ifelse(is.na(datavalueunit), "", datavalueunit)) %>%
select(topic, questionid, datavaluetype, datavalueunit) %>%
distinct() %>%
arrange(topic, questionid, datavaluetype, datavalueunit)
topics <- sort(unique(df_clean$topic))
if (!is.null(SHOW_TOPICS)) {
topics <- intersect(topics, SHOW_TOPICS)
}
# --- Funzione: crea e disegna le tabelle per un topic nel notebook ---
draw_topic_tables <- function(topic_name, data, max_rows_per_block = 40) {
tab <- data %>%
filter(topic == topic_name) %>%
select(questionid, datavaluetype, datavalueunit) %>%
arrange(questionid, datavaluetype, datavalueunit)
if (nrow(tab) == 0) {
grid.newpage()
grid.draw(tableGrob(
data.frame(Messaggio = sprintf("Nessuna combinazione per topic: %s", topic_name)),
rows = NULL
))
return(invisible(NULL))
}
# spezza in blocchi se lungo
blocks <- split(tab, ceiling(seq_len(nrow(tab)) / max_rows_per_block))
for (i in seq_along(blocks)) {
sub <- blocks[[i]]
tg <- tableGrob(
sub,
rows = NULL,
theme = ttheme_minimal(
core = list(fg_params = list(cex = 0.75)),
colhead = list(fg_params = list(fontface = "bold", cex = 0.8))
)
)
title_text <- if (length(blocks) == 1) {
sprintf("Topic: %s — datavaluetype e datavalueunit per QuestionID", topic_name)
} else {
sprintf("Topic: %s — datavaluetype e datavalueunit per QuestionID (Parte %d/%d)",
topic_name, i, length(blocks))
}
title <- textGrob(title_text, gp = gpar(fontface = "bold", cex = 1))
padding <- unit(5, "mm")
g <- gtable_add_rows(tg, heights = grobHeight(title) + padding, pos = 0)
g <- gtable_add_grob(g, title, t = 1, l = 1, r = ncol(g))
grid.newpage()
grid.draw(g)
}
}
# --- Disegna tutte le tabelle nel notebook (una "pagina" per topic/blocco) ---
for (tp in topics) {
draw_topic_tables(tp, df_clean, max_rows_per_block = MAX_ROWS_PER_BLOCK)
}
library(ggplot2)
# ---------------- Parametri ----------------
DATASET_PATH <- "u_s_chronic_disease_indicators_cdi.csv"
TOP_N_COMBINATIONS <- NULL  # es. 20 per limitare; NULL = tutte
MIN_ROWS_PER_COMBO <- 1     # es. 30 per mostrare solo combinazioni con almeno 30 righe
FACET_THRESHOLD <- 16       # se #combo <= 16 usa facet unico, altrimenti loop
# --------------- Caricamento ---------------
df <- read.csv(DATASET_PATH, na.strings = c("", "NA", "NULL", "null"),
stringsAsFactors = FALSE)
names(df) <- tolower(names(df))
stopifnot(all(c("questionid","datavaluetype","datavalue") %in% names(df)))
# datavalue numerico e rimozione NA
df$datavalue <- suppressWarnings(as.numeric(df$datavalue))
df <- df %>% filter(!is.na(datavalue))
# --------------- Scelta combinazioni ---------------
# Conta righe per combinazione e ordina (più popolose prima)
combo_stats <- df %>%
count(questionid, datavaluetype, name = "n_rows") %>%
arrange(desc(n_rows)) %>%
filter(n_rows >= MIN_ROWS_PER_COMBO)
if (!is.null(TOP_N_COMBINATIONS)) {
combo_stats <- head(combo_stats, TOP_N_COMBINATIONS)
}
# --------------- Frequenze per valore ---------------
freq_df <- df %>%
semi_join(combo_stats, by = c("questionid","datavaluetype")) %>%
group_by(questionid, datavaluetype, datavalue) %>%
summarise(frequency = n(), .groups = "drop") %>%
arrange(questionid, datavaluetype, datavalue)
# Se non c'è nulla da plottare, esci
if (nrow(freq_df) == 0) {
stop("Nessun dato disponibile dopo i filtri (controlla MIN_ROWS_PER_COMBO/TOP_N_COMBINATIONS).")
}
# Ordini fattori per un layout stabile
freq_df <- freq_df %>%
mutate(
questionid    = factor(questionid, levels = unique(combo_stats$questionid)),
datavaluetype = factor(datavaluetype, levels = unique(combo_stats$datavaluetype))
)
num_combos <- nrow(combo_stats)
# --------------- Caso A: Facet unico (≤ FACET_THRESHOLD) ---------------
if (num_combos <= FACET_THRESHOLD) {
# Facet per combinazione questionid × datavaluetype
p <- ggplot(freq_df, aes(x = datavalue, y = frequency)) +
geom_col(fill = "blue", alpha = 0.7, width = 0.9) +
facet_grid(datavaluetype ~ questionid, scales = "free_y") +
labs(
title = "Distribuzione di Frequenza di datavalue per QuestionID × DataValueType",
x = "datavalue",
y = "Frequenza"
) +
theme_minimal(base_size = 11) +
theme(
strip.text = element_text(face = "bold"),
plot.title = element_text(face = "bold"),
panel.grid.minor = element_blank()
)
print(p)
# --------------- Caso B: Molte combinazioni → stampa una per volta ---------------
} else {
# Loop e stampa nel notebook
combos <- combo_stats %>% select(questionid, datavaluetype)
for (i in seq_len(nrow(combos))) {
qi  <- combos$questionid[i]
dvt <- combos$datavaluetype[i]
sub <- freq_df %>%
filter(questionid == qi, datavaluetype == dvt)
if (nrow(sub) == 0) next
p <- ggplot(sub, aes(x = datavalue, y = frequency)) +
geom_col(fill = "blue", alpha = 0.7, width = 0.9) +
labs(
title = paste("Distribuzione di Frequenza —", qi, "—", dvt),
x = "datavalue",
y = "Frequenza"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(face = "bold"),
panel.grid.minor = element_blank()
)
print(p)
}
}
library(DT)
library(stringr)
dataset_path <- "u_s_chronic_disease_indicators_cdi.csv"
df <- read.csv(dataset_path, na.strings = c("", "NA", "NULL", "null"),
stringsAsFactors = FALSE)
names(df) <- tolower(names(df))
# tieni solo i datavaluetypeid di interesse
keep_types <- c("LclCntrlAlc", "CommHstLiab", "YesNo")
df_filtered <- df %>%
filter(datavaluetypeid %in% keep_types)
# Assicura che datavalue sia trattato come qualitativo (character)
df_filtered <- df_filtered %>%
mutate(datavalue = as.character(datavalue))
# Funzione moda robusta: ignora NA, ritorna tutte le mode (in caso di ex-aequo)
mode_stats <- function(x) {
x <- x[!is.na(x)]
if (length(x) == 0) {
return(list(mode_value = NA_character_, mode_count = NA_integer_, n = 0))
}
tab <- sort(table(x), decreasing = TRUE)
maxc <- as.integer(tab[1])
modes <- names(tab[tab == maxc])
list(
mode_value = paste(modes, collapse = " | "),  # tutte le mode
mode_count = maxc,
n = length(x)
)
}
# Calcolo moda e statistiche per topic × questionid × datavaluetypeid
modes_df <- df_filtered %>%
group_by(topic, questionid, datavaluetypeid) %>%
summarise(
stats = list(mode_stats(datavalue)),
.groups = "drop"
) %>%
mutate(
mode_value = vapply(stats, `[[`, character(1), "mode_value"),
mode_count = vapply(stats, `[[`, integer(1),   "mode_count"),
n          = vapply(stats, `[[`, integer(1),   "n"),
mode_pct   = ifelse(n > 0, round(100 * mode_count / n, 1), NA_real_)
) %>%
select(topic, questionid, datavaluetypeid, mode_value, mode_count, mode_pct, n) %>%
arrange(topic, questionid, datavaluetypeid)
# Mostra direttamente nel notebook (tabella interattiva filtrabile/ordinabile)
datatable(
modes_df,
rownames = FALSE,
filter = "top",
options = list(pageLength = 25, autoWidth = TRUE),
colnames = c(
"Topic", "QuestionID", "DataValueTypeID",
"Moda (valori)", "Frequenza moda", "% moda", "N osservazioni"
),
class = "display compact nowrap"
)
library(DT)
library(stringr)
dataset_path <- "u_s_chronic_disease_indicators_cdi.csv"
df <- read.csv(dataset_path, na.strings = c("", "NA", "NULL", "null"),
stringsAsFactors = FALSE)
names(df) <- tolower(names(df))
# tieni solo i datavaluetypeid di interesse
keep_types <- c("LclCntrlAlc", "CommHstLiab", "YesNo")
df_filtered <- df %>%
filter(datavaluetypeid %in% keep_types)
# Assicura che datavalue sia trattato come qualitativo (character)
df_filtered <- df_filtered %>%
mutate(datavalue = as.character(datavalue))
# Funzione moda robusta: ignora NA, ritorna tutte le mode (in caso di ex-aequo)
mode_stats <- function(x) {
x <- x[!is.na(x)]
if (length(x) == 0) {
return(list(mode_value = NA_character_, mode_count = NA_integer_, n = 0))
}
tab <- sort(table(x), decreasing = TRUE)
maxc <- as.integer(tab[1])
modes <- names(tab[tab == maxc])
list(
mode_value = paste(modes, collapse = " | "),  # tutte le mode
mode_count = maxc,
n = length(x)
)
}
# Calcolo moda e statistiche per topic × questionid × datavaluetypeid
modes_df <- df_filtered %>%
group_by(topic, questionid, datavaluetypeid) %>%
summarise(
stats = list(mode_stats(datavalue)),
.groups = "drop"
) %>%
mutate(
mode_value = vapply(stats, `[[`, character(1), "mode_value"),
mode_count = vapply(stats, `[[`, integer(1),   "mode_count"),
n          = vapply(stats, `[[`, integer(1),   "n"),
mode_pct   = ifelse(n > 0, round(100 * mode_count / n, 1), NA_real_)
) %>%
select(topic, questionid, datavaluetypeid, mode_value, mode_count, mode_pct, n) %>%
arrange(topic, questionid, datavaluetypeid)
# Mostra direttamente nel notebook (tabella interattiva filtrabile/ordinabile)
datatable(
modes_df,
rownames = FALSE,
filter = "top",
options = list(pageLength = 25, autoWidth = TRUE),
colnames = c(
"Topic", "QuestionID", "DataValueTypeID",
"Moda (valori)", "Frequenza moda", "% moda", "N osservazioni"
),
class = "display compact nowrap"
)
# --- Librerie ---
library(tidyverse)
library(janitor)
library(grid)
library(gtable)
library(gridExtra)    # tableGrob / arrangeGrob
library(ggplotify)    # as.ggplot -> consente ggsave su grob
# --- Unica dipendenza esterna ---
# install.packages("gridExtra") # se serve
library(gridExtra)  # tableGrob, arrangeGrob, ttheme_minimal
# (grid viene caricato automaticamente)
# --- Parametri ---
dataset_path <- "u_s_chronic_disease_indicators_cdi.csv"
MAX_ROWS_PER_BLOCK <- 40                 # righe per tabella prima di spezzare
SHOW_TOPICS <- NULL                      # es. c("Alcohol","Cancer") o NULL per tutti
OUTPUT_DIR <- "tabelle_topic"            # cartella output immagini
IMG_EXT <- "png"                         # "png" o "jpg"
WIDTH <- 1600                            # pixel
HEIGHT <- 1000                           # pixel
DPI <- 150                               # non usato da png(), utile se converti
# --- Helper: slug per nomi file ---
slugify <- function(x) {
x <- tolower(gsub("[^a-z0-9]+", "-", x))
gsub("(^-|-$)", "", x)
}
if (!dir.exists(OUTPUT_DIR)) dir.create(OUTPUT_DIR, recursive = TRUE)
# --- Caricamento e preparazione (solo base R) ---
df <- read.csv(dataset_path, stringsAsFactors = FALSE, check.names = FALSE)
names(df) <- tolower(names(df))
req_cols <- c("topic", "questionid", "datavaluetype", "datavalueunit")
miss <- setdiff(req_cols, names(df))
if (length(miss) > 0) stop(paste("Mancano colonne:", paste(miss, collapse = ", ")))
# pulizia minima
dvunit <- df[["datavalueunit"]]
dvunit[is.na(dvunit)] <- ""
df_clean <- unique(data.frame(
topic = df[["topic"]],
questionid = df[["questionid"]],
datavaluetype = df[["datavaluetype"]],
datavalueunit = dvunit,
stringsAsFactors = FALSE
))
ord <- with(df_clean, order(topic, questionid, datavaluetype, datavalueunit))
df_clean <- df_clean[ord, , drop = FALSE]
topics <- sort(unique(df_clean$topic))
if (!is.null(SHOW_TOPICS)) topics <- intersect(topics, SHOW_TOPICS)
# --- Funzione: crea grob con titolo + tabella ---
make_table_grob <- function(title_text, df_block) {
# tema semplice e compatto
tg <- tableGrob(
df_block,
rows = NULL,
theme = ttheme_minimal(
core = list(fg_params = list(cex = 0.75, fontface = 1)),
colhead = list(fg_params = list(cex = 0.85, fontface = 2))
)
)
title_grob <- grid::textGrob(title_text, gp = grid::gpar(fontface = "bold", cex = 1.2))
gridExtra::arrangeGrob(
title_grob, tg,
ncol = 1,
heights = grid::unit.c(grid::grobHeight(title_grob) + grid::unit(6, "mm"), grid::unit(1, "null"))
)
}
# --- Disegno nel notebook e salvataggio su file (uno per topic/parte) ---
for (tp in topics) {
tab <- df_clean[df_clean$topic == tp, c("questionid", "datavaluetype", "datavalueunit"), drop = FALSE]
if (nrow(tab) == 0) {
msg <- sprintf("Nessuna combinazione per topic: %s", tp)
grob <- make_table_grob(msg, data.frame(Messaggio = msg))
# mostra nel notebook
grid::grid.newpage(); grid::grid.draw(grob)
# salva
out_path <- file.path(OUTPUT_DIR, paste0("topic-", slugify(tp), ".", IMG_EXT))
if (IMG_EXT == "png") {
png(out_path, width = WIDTH, height = HEIGHT, res = DPI); grid::grid.draw(grob); dev.off()
} else {
jpeg(out_path, width = WIDTH, height = HEIGHT, quality = 95); grid::grid.draw(grob); dev.off()
}
next
}
# split in blocchi
idx <- ceiling(seq_len(nrow(tab)) / MAX_ROWS_PER_BLOCK)
blocks <- split(tab, idx)
for (i in seq_along(blocks)) {
title <- if (length(blocks) == 1) {
sprintf("Topic: %s — datavaluetype e datavalueunit per QuestionID", tp)
} else {
sprintf("Topic: %s — datavaluetype e datavalueunit per QuestionID (Parte %d/%d)", tp, i, length(blocks))
}
grob <- make_table_grob(title, blocks[[i]])
# mostra nel notebook
grid::grid.newpage(); grid::grid.draw(grob)
# salva file
suff <- if (length(blocks) == 1) "" else sprintf("-part-%02d", i)
out_path <- file.path(OUTPUT_DIR, paste0("topic-", slugify(tp), suff, ".", IMG_EXT))
if (IMG_EXT == "png") {
png(out_path, width = WIDTH, height = HEIGHT, res = DPI); grid::grid.draw(grob); dev.off()
} else {
jpeg(out_path, width = WIDTH, height = HEIGHT, quality = 95); grid::grid.draw(grob); dev.off()
}
}
}
library(DT)
dataset <- "u_s_chronic_disease_indicators_cdi.csv"
df <- read.csv(dataset, stringsAsFactors = FALSE)
names(df) <- tolower(names(df))
# (opzionale) filtra un topic specifico
# df <- dplyr::filter(df, topic == "Alcohol")
result <- df %>%
group_by(questionid, stratificationcategory1, stratification1) %>%
summarise(Num_Entry = n(), .groups = "drop") %>%
rename(
QuestionID = questionid,
Stratification_Category = stratificationcategory1,
Stratification = stratification1
) %>%
arrange(QuestionID, Stratification_Category, Stratification)
datatable(
result,
rownames = FALSE,
options = list(pageLength = 25, autoWidth = TRUE),
filter = "top",
class = "display compact nowrap"
)
# ============================================================
# Script R: Confronto Statistiche Dataset Originale vs Sintetico
# ============================================================
# --- Parametri modificabili ---
path_original <- "diabetes_subdataset.csv"
path_synthetic <- "diabetes_subdataset_imputed.csv"
strat_filter <- "Overall"   # Filtra stratificationcategory1
years_keep <- NULL          # es. c(2015,2016), altrimenti NULL
types_keep <- c("Crude Prevalence", "Age-adjusted Prevalence", "Crude Rate")
output_file <- "confronto_statistiche.jpg"
# --- Librerie ---
library(tidyverse)
library(readr)
library(janitor)
# --- Funzione di pulizia ---
clean_data <- function(path, origine) {
df <- read_csv(path, show_col_types = FALSE) %>%
clean_names() %>%
filter(locationabbr != "US") %>%
filter(stratificationcategory1 == strat_filter) %>%
mutate(
datavalue = suppressWarnings(parse_number(as.character(datavalue))),
origine = origine,
datavaluetype = str_trim(str_to_title(datavaluetype))
) %>%
filter(!is.na(datavalue))
if (!is.null(years_keep)) {
df <- df %>% filter(yearstart %in% years_keep)
}
return(df)
}
# --- Caricamento dati ---
df_orig <- clean_data(path_original, "Originale")
df_synth <- clean_data(path_synthetic, "Sintetico")
# --- Unione dataset ---
df_all <- bind_rows(df_orig, df_synth)
# --- Selezione tipi di interesse ---
if (!"Age-Adjusted Prevalence" %in% unique(df_all$datavaluetype) &&
"Age-Adjusted Rate" %in% unique(df_all$datavaluetype)) {
types_keep <- c("Crude Prevalence", "Age-Adjusted Rate", "Crude Rate")
}
df_all <- df_all %>% filter(datavaluetype %in% types_keep)
# --- Calcolo statistiche ---
stats_df <- df_all %>%
group_by(origine, datavaluetype, stratificationcategory1, yearstart,
across(matches("questionid", ignore.case = TRUE), .names = "questionid")) %>%
summarise(
n = n(),
mean = mean(datavalue, na.rm = TRUE),
median = median(datavalue, na.rm = TRUE),
sd = sd(datavalue, na.rm = TRUE),
min = min(datavalue, na.rm = TRUE),
q25 = quantile(datavalue, 0.25, na.rm = TRUE),
q75 = quantile(datavalue, 0.75, na.rm = TRUE),
max = max(datavalue, na.rm = TRUE),
.groups = "drop"
)
# --- Reshape in long format ---
stats_long <- stats_df %>%
pivot_longer(
cols = c("max","mean","median","sd","min","q25","q75"),
names_to = "metrica", values_to = "valore"
) %>%
mutate(metrica = factor(metrica, levels = c("max","mean","median","sd","min","q25","q75")))
# --- Verifiche a console ---
print("Head dataframe statistiche:")
print(head(stats_long))
print("Livelli datavaluetype usati:")
print(unique(stats_long$datavaluetype))
print("Numero stati unici:")
print(length(unique(df_all$locationabbr)))
# --- Plot ---
facet_formula <- if ("questionid" %in% colnames(stats_long)) {
as.formula("~ datavaluetype + questionid")
} else {
as.formula("~ datavaluetype")
}
p <- ggplot(stats_long, aes(x = metrica, y = valore, group = origine, colour = origine)) +
geom_line() +
geom_point(size = 2) +
facet_wrap(facet_formula, scales = "free_y") +
labs(
title = "Confronto Statistiche: Dataset Originale vs Sintetico",
subtitle = paste("Stratification:", strat_filter),
x = "Metrica Statistica",
y = "Valore",
colour = "Origine Dato"
) +
scale_colour_manual(values = c("Originale" = "red", "Sintetico" = "blue")) +
theme_minimal(base_size = 14) +
theme(
axis.text.x = element_text(angle = 45, hjust = 1),
panel.border = element_rect(colour = "grey80", fill = NA)
)
# --- Salvataggio output ---
ggsave(output_file, p, width = 16, height = 9, dpi = 300)
